import os, time, queue, shutil
import threading, subprocess
from PyQt5.QtCore import QThread, pyqtSignal

class InstallDllsWorker(QThread):

    log = pyqtSignal(str)

    def __init__(self, base):    super().__init__(); self.base = base

    def run(self):
        if shutil.which("winetricks") is None:
            self.log.emit("‚ùå winetricks isn't Installed."); return

        self._start_winetricks()

    def _start_winetricks(self):
        try:
            self.log.emit("‚ö° Opening Winetricks GUI...")
            subprocess.Popen(["winetricks"], env={"WINEPREFIX": self.base, **os.environ})
            self.log.emit(f"‚úÖ Terminal-Command: $ WINEPREFIX={self.base} winetricks")
        except Exception as e:    self.log.emit(f"‚ùå Failed to start winetricks: {e}")


class TemprefixWorker(QThread):
    log = pyqtSignal(str); done = pyqtSignal(bool)

    def __init__(self, exe, base, temp, wine):
        super().__init__()
        self.base, self.temp, self.wine, self.exe = base, temp, wine, exe

    def run(self):
        u, w, m = [os.path.join(self.temp, p) for p in ("upper", "work", "merged")]
        self._prepare_dirs(u, w, m)
        fs = self._detect_fs(self.temp)
        self._create_tprefix(u, w, m, fs)
        self._initialize_tprefix(m)

    def _prepare_dirs(self, u, w, m):
        try:
            time.sleep(0.3)
            [os.makedirs(d, exist_ok=True) for d in (u, w, m)]
        except OSError as e:    self.log.emit(f"‚ùå Directory couldn't prepare: {e}"); self.done.emit(False)

    def _detect_fs(self, path):
        try:
            out = subprocess.run(["df", "-T", path], capture_output=True, text=True, check=True).stdout
            return out.splitlines()[1].split()[1].lower()
        except subprocess.CalledProcessError:    self.log.emit(f"‚ùå Error detecting filesystem"); return "unknown"

    def _create_tprefix(self, u, w, m, fs):
        try:
            if fs in ("ext4", "btrfs", "xfs"):
                cmd = ["pkexec", "mount", "-t", "overlay", "overlay", 
                       "-o", f"lowerdir={self.base},upperdir={u},workdir={w}", m]
                fs_type = "native OverlayFS"
            else:
                cmd = ["fuse-overlayfs", "-o", f"lowerdir={self.base},upperdir={u},workdir={w}", m]
                fs_type = "fuse-overlayfs"
    
            self.log.emit(f"‚ö° Using {fs_type} on {fs}.") ; subprocess.run(cmd, check=True)
            
            self.log.emit(f"‚úÖ TPrefix created at {m}")
        except subprocess.CalledProcessError as e: self.log.emit(f"‚ùå Overlay couldn't mount: {e}"); self.done.emit(False)

    def _initialize_tprefix(self, m):
        try:
            env = {**os.environ, "WINEPREFIX": m, "WINEDLLOVERRIDES": "dll=ignore", "WINEDEBUG": "-all"}
            os.makedirs(os.path.join(m, "drive_c", "windows"), exist_ok=True)
            if not os.path.exists(os.path.join(m, "user.reg")):
                subprocess.run([self.wine, "wineboot", "-u"], env=env, cwd=os.path.dirname(self.exe), check=True)
            self.log.emit("‚úÖ TPrefix Initialized with Windows 10."); self.done.emit(True)
        except subprocess.CalledProcessError as e:    self.log.emit(f"‚ùå TPrefix couldn't setup: {e}"); self.done.emit(False)



class DeleteTempPrefixWorker(QThread):
    log = pyqtSignal(str)

    def __init__(self, temp):    super().__init__(); self.temp = temp

    def run(self):
        if not os.path.exists(self.temp):
            self.log.emit("‚ÑπÔ∏è No Temp Prefix found.")
            return
        self._delete_temp_prefix()

    def _delete_temp_prefix(self):
        m = os.path.join(self.temp, "merged")
        try:
            for cmd in (["fusermount", "-u", m], ["pkexec", "umount", "-l", m]):
                subprocess.run(cmd, check=False)
            time.sleep(0.3)
            self._execute_deletion()
        except Exception as e:    self.log.emit(f"‚ùå Deletion failed: {e}")

    def _execute_deletion(self):
        try:
            self.log.emit("‚ö° Using Pkexec for deletion...")
            subprocess.run(["pkexec", "rm", "-rf", self.temp], check=True)
            self.log.emit("‚úÖ Temp Prefix deleted via Pkexec.")
        except Exception:    self.log.emit("‚ùå Deletion failed.")


class AnalyzeAndRunExeWorker(QThread):
    log = pyqtSignal(str)
    started_signal = pyqtSignal(str)

    def __init__(self, exe, temp, wine):
        super().__init__()

        self.temp = temp ; self.exe = exe ; self.wine = wine

    def run(self):

        m = os.path.join(self.temp, "merged")
        env = self._setup_env(m)
        self._launch_exe(env, m)

    def _setup_env(self, m):
        return {
            **os.environ,
            "WINEPREFIX": m,
            "WINE_FULLSCREEN": "0",
            "WINEDEBUG": "+timestamp,+warn",
            "WINE_ALLOW_LARGE_ALLOCS": "1",
            "WINEESYNC": "1",
            "WINEFSYNC": "1",
            "WINEASYNC": "0",
        }

    def _launch_exe(self, env, m):
        cmd = [self.wine, self.exe]
        self.started_signal.emit(f"üöÄ Launching EXE:\n$ {' '.join([f'{k}={v}' for k, v in env.items() if k.startswith('WINE')])} {' '.join(cmd)}")

        try:
            proc = subprocess.Popen(cmd, env=env, cwd=os.path.dirname(self.exe), stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
            self._monitor_proc_output(proc)
        except Exception as e:    self.log.emit(f"‚ùå Launch failed: {e}")

    def _monitor_proc_output(self, proc):
        q = queue.Queue()
        def reader_thread():
            for line in iter(proc.stdout.readline, ''):    q.put(line.strip())
            proc.stdout.close()

        threading.Thread(target=reader_thread, daemon=True).start()

        missing_dlls = set()
        while proc.poll() is None or not q.empty():
            try:
                line = q.get(timeout=0.2)
                if line:
                    self.log.emit(line)
                    if ".dll" in line.lower() and ("cannot" in line.lower() or "not found" in line.lower()):
                        missing_dlls.add(line.split()[0].lower())
            except queue.Empty:    pass

        proc.wait()
        self._log_missing_dlls(missing_dlls, proc)

    def _log_missing_dlls(self, missing_dlls, proc):
        with open(os.path.join(os.path.dirname(self.exe), "Analyzable-logs.txt"), "w") as f:f.write("\n".join(missing_dlls))

        if missing_dlls:    self.log.emit(f"‚ùó Missing DLLs: {', '.join(sorted(missing_dlls))}")
        else:    self.log.emit("‚úÖ No missing DLLs detected.")

        self.log.emit("‚úÖ Execution finished." if proc.returncode == 0 else "‚ö†Ô∏è EXE exited with error.")
