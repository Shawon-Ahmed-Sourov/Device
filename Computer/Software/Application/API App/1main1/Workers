# Workers.py
import os
import subprocess
import shutil
import time
import queue
import threading
from PyQt5.QtCore import QThread, pyqtSignal

class InstallDllsWorker(QThread):
    log = pyqtSignal(str)

    def __init__(self, base):    super().__init__(); self.base = base

    def run(self):
        try:
            if shutil.which("winetricks") is None: self.log.emit("‚ùå winetricks not found. Please install it."); return

            self.log.emit("‚ö° Opening Winetricks GUI...")
            subprocess.Popen(["winetricks"], env={"WINEPREFIX": self.base, **os.environ})
            self.log.emit(f"‚úÖ Terminal-Command: $ WINEPREFIX={self.base} winetricks")
        except Exception as e:
            self.log.emit(f"‚ùå Failed to start winetricks: {e}")

class TemprefixWorker(QThread):

    log = pyqtSignal(str); done = pyqtSignal(bool)

    def __init__(self, exe, base, temp, wine):
        super().__init__()
        self.exe = exe ; self.base = base; self.temp = temp ; self.wine = wine

    def detect_fs(self, path):
        try:
            out = subprocess.run(["df", "-T", path], capture_output=True, text=True, check=True).stdout
            return out.splitlines()[1].split()[1].lower()
        except:    return "unknown"

    def run(self):
        u, w, m = [os.path.join(self.temp, p) for p in ("upper", "work", "merged")]
        try:
            for cmd in (["fusermount", "-u", m], ["sudo", "umount", "-l", m]):    subprocess.run(cmd, check=False)
            time.sleep(0.3)
            [os.makedirs(d, exist_ok=True) for d in (u, w, m)]

            fs = self.detect_fs(self.temp)

            if fs in ("ext4", "btrfs", "xfs"):
                cmd = [
                    "sudo", "mount", "-t", "overlay", "overlay", "-o",
                    f"lowerdir={self.base},upperdir={u},workdir={w}", m,
                ]
                self.log.emit(f"‚ö° Using native OverlayFS on {fs}.")
            else:
                cmd = [
                    "fuse-overlayfs", "-o",
                    f"lowerdir={self.base},upperdir={u},workdir={w}", m,
                ]
                self.log.emit(f"‚ö° Using fuse-overlayfs on {fs}.")

            subprocess.run(cmd, check=True)
            self.log.emit(f"‚úÖ Temp Prefix created at {m}")

            env = {**os.environ, "WINEPREFIX": m, "WINEDLLOVERRIDES": "mscoree,mshtml=", "WINEDEBUG": "-all"}
            os.makedirs(os.path.join(m, "drive_c", "windows"), exist_ok=True)

            if not os.path.exists(os.path.join(m, "user.reg")):
                subprocess.run([self.wine, "wineboot", "-u"], env=env, cwd=os.path.dirname(self.exe), check=True)

            self.log.emit("‚úÖ Temp Prefix initialized and set to Windows 10.")
            self.done.emit(True)

        except Exception as e:    self.log.emit(f"‚ùå Temp Prefix setup failed: {e}"); self.done.emit(False)


class DeleteTempPrefixWorker(QThread):
    log = pyqtSignal(str)

    def __init__(self, temp):
        super().__init__()
        self.temp = temp

    def run(self):

        if not os.path.exists(self.temp):    self.log.emit("‚ÑπÔ∏è No Temp Prefix found."); return
        self.log.emit("üóëÔ∏è Deleting Temp Prefix...")
        m = os.path.join(self.temp, "merged")

        try:
            for cmd in (["fusermount", "-u", m], ["sudo", "umount", "-l", m]):    subprocess.run(cmd, check=False)
            time.sleep(0.3)
            shutil.rmtree(self.temp)
            self.log.emit("‚úÖ Temp Prefix deleted.")

        except PermissionError:
            self.log.emit("‚ö° Using sudo for deletion...")
            try:
                subprocess.run(["sudo", "rm", "-rf", self.temp], check=True)
                self.log.emit("‚úÖ Temp Prefix deleted via sudo.")
            except Exception:
                self.log.emit("‚ùå Deletion failed.")
        except Exception:
            self.log.emit("‚ùå Deletion failed unexpectedly.")

class AnalyzeAndRunExeWorker(QThread):
    log = pyqtSignal(str); started_signal = pyqtSignal(str)

    def __init__(self, exe, temp, wine):
        super().__init__(); self.exe = exe; self.temp = temp; self.wine = wine

    def run(self):
        try:
            m = os.path.join(self.temp, "merged")
            env = {
                **os.environ, 
                "WINEPREFIX": m, 
                "WINEESYNC": "1", 
                "WINEFSYNC": "1", 
                "WINEASYNC": "0",
                "WINE_FULLSCREEN": "0",
                "WINE_ALLOW_LARGE_ALLOCS": "1", 
                "WINEDEBUG": "+timestamp,+warn"
            }
            cmd = [self.wine, self.exe]
            cmd_display = " ".join(f'{k}={v}' for k, v in env.items() if k.startswith("WINE")) + " " + " ".join(cmd)
            self.started_signal.emit(f"üöÄ Launching EXE:\n$ {cmd_display}")

            proc = subprocess.Popen(
                cmd, env=env, cwd=os.path.dirname(self.exe),
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1
            )
            q = queue.Queue()

            def reader_thread():
                for line in iter(proc.stdout.readline, ''): q.put(line.strip())
                proc.stdout.close()

            threading.Thread(target=reader_thread, daemon=True).start()

            missing_dlls = set()
            while proc.poll() is None or not q.empty():
                try:
                    line = q.get(timeout=0.2)
                    if line:
                        self.log.emit(line)
                        if ".dll" in line.lower() and ("cannot" in line.lower() or "not found" in line.lower()):
                            missing_dlls.add(line.split()[0].lower())

                except queue.Empty:    pass

            proc.wait()
            with open(os.path.join(os.path.dirname(self.exe), "Analyzable-wineoutput.txt"), "w") as f:
                f.write("\n".join(missing_dlls))

            self.log.emit(f"‚ùó Missing DLLs: {', '.join(sorted(missing_dlls))}" if missing_dlls else "‚úÖ No missing DLLs detected.")
            self.log.emit("‚úÖ Execution finished." if proc.returncode == 0 else "‚ö†Ô∏è EXE exited with error.")

        except subprocess.TimeoutExpired:
            self.log.emit("‚è±Ô∏è Process timed out, terminating...")
            proc.kill()
        except Exception as e:    self.log.emit(f"‚ùå Launch failed: {e}")
