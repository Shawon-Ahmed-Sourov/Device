import os, time, queue, shutil
import threading, subprocess
from PyQt5.QtCore import QThread, pyqtSignal


# Helper functions
def run_subprocess(cmd, env=None, cwd=None, check=True, capture_output=False):
    try:
        return subprocess.run(cmd, env=env, cwd=cwd, check=check, capture_output=capture_output, text=True)
    except subprocess.CalledProcessError as e:
        return e


def detect_fs(path):
    try:
        out = subprocess.run(["df", "-T", path], capture_output=True, text=True, check=True).stdout
        return out.splitlines()[1].split()[1].lower()
    except:
        return "unknown"


# Base Worker class
class BaseWorker(QThread):
    log = pyqtSignal(str)

    def emit_log(self, msg):
        self.log.emit(msg)


# Worker for installing DLLs via Winetricks
class InstallDllsWorker(BaseWorker):
    def __init__(self, base):
        super().__init__()
        self.base = base

    def run(self):
        if shutil.which("winetricks") is None:
            self.emit_log("‚ùå winetricks not found. Please install it.")
            return

        self.emit_log("‚ö° Opening Winetricks GUI...")
        subprocess.Popen(["winetricks"], env={"WINEPREFIX": self.base, **os.environ})
        self.emit_log(f"‚úÖ Terminal-Command: $ WINEPREFIX={self.base} winetricks")


# Worker to setup a temporary Wine prefix
class TemprefixWorker(BaseWorker):
    done = pyqtSignal(bool)

    def __init__(self, exe, base, temp, wine):
        super().__init__()
        self.exe, self.base, self.temp, self.wine = exe, base, temp, wine

    def run(self):
        u, w, m = [os.path.join(self.temp, p) for p in ("upper", "work", "merged")]

        for cmd in [["fusermount", "-u", m], ["sudo", "umount", "-l", m]]:
            run_subprocess(cmd, check=False)
        time.sleep(0.3)

        for d in (u, w, m):
            os.makedirs(d, exist_ok=True)

        fs = detect_fs(self.temp)
        mount_cmd = self.get_overlay_mount_cmd(fs, u, w, m)

        if mount_cmd:
            run_subprocess(mount_cmd, check=True)
            self.emit_log(f"‚úÖ Temp Prefix created at {m}")

            self.setup_wine_prefix(m)

    def get_overlay_mount_cmd(self, fs, u, w, m):
        if fs in ("ext4", "btrfs", "xfs"):
            self.emit_log(f"‚ö° Using native OverlayFS on {fs}.")
            return ["sudo", "mount", "-t", "overlay", "overlay", "-o", f"lowerdir={self.base},upperdir={u},workdir={w}", m]
        else:
            self.emit_log(f"‚ö° Using fuse-overlayfs on {fs}.")
            return ["fuse-overlayfs", "-o", f"lowerdir={self.base},upperdir={u},workdir={w}", m]

    def setup_wine_prefix(self, m):
        env = {**os.environ, "WINEPREFIX": m, "WINEDLLOVERRIDES": "mscoree,mshtml=", "WINEDEBUG": "-all"}
        os.makedirs(os.path.join(m, "drive_c", "windows"), exist_ok=True)

        if not os.path.exists(os.path.join(m, "user.reg")):
            run_subprocess([self.wine, "wineboot", "-u"], env=env, cwd=os.path.dirname(self.exe), check=True)

        self.emit_log("‚úÖ Temp Prefix initialized and set to Windows 10.")
        self.done.emit(True)


# Worker to delete the temporary Wine prefix
class DeleteTempPrefixWorker(BaseWorker):
    def __init__(self, temp):
        super().__init__()
        self.temp = temp

    def run(self):
        if not os.path.exists(self.temp):
            self.emit_log("‚ÑπÔ∏è No Temp Prefix found.")
            return

        self.emit_log("üóëÔ∏è Deleting Temp Prefix...")
        m = os.path.join(self.temp, "merged")

        self.cleanup_mount(m)
        time.sleep(0.3)

        try:
            shutil.rmtree(self.temp)
            self.emit_log("‚úÖ Temp Prefix deleted.")
        except PermissionError:
            self.emit_log("‚ö° Using sudo for deletion...")
            run_subprocess(["sudo", "rm", "-rf", self.temp], check=True)
            self.emit_log("‚úÖ Temp Prefix deleted via sudo.")
        except Exception as e:
            self.emit_log(f"‚ùå Deletion failed: {e}")

    def cleanup_mount(self, m):
        # Ensure the mount point exists before trying to unmount it
        if os.path.exists(m):
            for cmd in [["fusermount", "-u", m], ["sudo", "umount", "-l", m]]:
                run_subprocess(cmd, check=False)
        else:
            self.emit_log(f"‚ÑπÔ∏è Mount point {m} does not exist, skipping unmount.")


# Worker to analyze and run an EXE using Wine
class AnalyzeAndRunExeWorker(BaseWorker):
    started_signal = pyqtSignal(str)

    def __init__(self, exe, temp, wine):
        super().__init__()
        self.exe, self.temp, self.wine = exe, temp, wine

    def run(self):
        m = os.path.join(self.temp, "merged")
        env = self.get_env(m)

        cmd = [self.wine, self.exe]
        self.started_signal.emit(f"üöÄ Launching EXE:\n$ {' '.join(f'{k}={v}' for k, v in env.items() if k.startswith('WINE'))} {' '.join(cmd)}")

        try:
            proc = subprocess.Popen(cmd, env=env, cwd=os.path.dirname(self.exe), stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT, text=True, bufsize=1)
            self.monitor_process_output(proc)
        except Exception as e:
            self.emit_log(f"‚ùå Failed to start EXE: {e}")
            self.emit_log("‚ö†Ô∏è Process did not start correctly.")
            return

    def get_env(self, m):
        return {
            **os.environ,
            "WINEPREFIX": m,
            "WINEESYNC": "1",
            "WINEFSYNC": "1",
            "WINEASYNC": "0",
            "WINE_FULLSCREEN": "0",
            "WINE_ALLOW_LARGE_ALLOCS": "1",
            "WINEDEBUG": "+timestamp,+warn"
        }

    def monitor_process_output(self, proc):
        q = queue.Queue()

        def reader_thread():
            for line in iter(proc.stdout.readline, ''):
                q.put(line.strip())
            proc.stdout.close()

        threading.Thread(target=reader_thread, daemon=True).start()

        missing_dlls = set()
        while proc.poll() is None or not q.empty():
            try:
                line = q.get(timeout=0.2)
                if line:
                    self.emit_log(line)
                    if ".dll" in line.lower() and ("cannot" in line.lower() or "not found" in line.lower()):
                        missing_dlls.add(line.split()[0].lower())
            except queue.Empty:
                pass

        # Check if the process has finished properly before accessing its return code
        proc.wait()
        self.write_missing_dlls(missing_dlls, proc)

    def write_missing_dlls(self, missing_dlls, proc):
        # Avoid accessing proc if it is None
        if hasattr(proc, 'returncode'):
            self.emit_log(f"‚úÖ Execution finished." if proc.returncode == 0 else "‚ö†Ô∏è EXE exited with error.")
        else:
            self.emit_log("‚ö†Ô∏è EXE terminated unexpectedly.")
        
        with open(os.path.join(os.path.dirname(self.exe), "Analyzable-wineoutput.txt"), "w") as f:
            f.write("\n".join(missing_dlls))

        self.emit_log(f"‚ùó Missing DLLs: {', '.join(sorted(missing_dlls))}" if missing_dlls else "‚úÖ No missing DLLs detected.")
