class RunAnalyze(QThread):

    log = pyqtSignal(str)
    done = pyqtSignal(bool)

    def __init__(self, exe_path, exe_file, tprefix_path=None, BepInEx_dll=None, preso=None):
        super().__init__()

        self.wine = "wine"
        self.exe_file = exe_file
        self.tprefix_path = tprefix_path
        self.exe_path = exe_path
        self.BepInEx_dll = BepInEx_dll
        self.preso = preso

        self.proc = None

    def run(self):
        cmd, merged_env = self._build_command()
        self._launch_exe(cmd, merged_env)

    def _build_command(self):

        env1 = {**os.environ, "WINEPREFIX": self.tprefix_path}
        env2 = {
            "WINE_FULLSCREEN": "0",
            "WINEDEBUG": "+timestamp,+warn",
            "WINE_ALLOW_LARGE_ALLOCS": "1",
            "WINEESYNC": "1",
            "WINEFSYNC": "1",
            "WINEASYNC": "0"
        }

        merged_env = {**env1, **env2}

        cmd = [self.wine]

        if self.BepInEx_dll:
            cmd += ["mono", self.BepInEx_dll]

        cmd += [self.exe_file]

        return cmd, merged_env

    def _launch_exe(self, cmd, env):

        self.log.emit(f"üöÄ Launching EXE:\n$ {' '.join(cmd)}")

        try:
            # merge stderr into stdout to avoid blocking
            self.proc = subprocess.Popen(
                cmd,
                env=env,
                cwd=os.path.dirname(self.exe_file),
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )

            if not self.proc:
                raise Exception("Failed to start the process.")

            self._monitor_proc(self.proc)

        except Exception as e:
            self.log.emit(f"‚ùå Error launching game: {e}")
            self.done.emit(False)

    def _monitor_proc(self, proc):
        q = queue.Queue()

        # Reader thread (non-blocking)
        def reader():
            for line in iter(proc.stdout.readline, ''):
                q.put(line.strip())
            proc.stdout.close()

        threading.Thread(target=reader, daemon=True).start()

        # Main event loop (non-blocking)
        while proc.poll() is None or not q.empty():
            try:
                line = q.get(timeout=0.1)
                if line:
                    self.log.emit(line)
            except queue.Empty:
                pass

        # Finished
        if proc.returncode == 0:
            self.log.emit("‚úÖ Process finished successfully.")
            self.done.emit(True)
        else:
            self.log.emit(f"‚ö†Ô∏è Process exited with code {proc.returncode}")
            self.done.emit(False)