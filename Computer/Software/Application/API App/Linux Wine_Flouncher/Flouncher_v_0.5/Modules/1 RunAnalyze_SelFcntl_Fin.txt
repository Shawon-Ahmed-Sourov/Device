import os, pty, subprocess, select, fcntl, time, resource
from PyQt5.QtCore import QThread, pyqtSignal

class RunAnalyze(QThread):
    log, done = pyqtSignal(str), pyqtSignal(bool)

    def __init__(self, exe_path, exe_file, tprefix_path=None, BepInEx_dll=None):
        super().__init__()
        self.wine, self.proc = "wine", None 
        self.tprefix_path, self.BepInEx_dll, self.exe_file = tprefix_path, BepInEx_dll, exe_file

    def run(self):

        self.log.emit("\n⚡ Launch has been Cliked.")
        cmd, env = self._build_command()
        m_fd, s_fd = None, None
        try:
            m_fd, s_fd = pty.openpty()
            # Fast-path: Set non-blocking to keep UI responsive
            fcntl.fcntl(m_fd, fcntl.F_SETFL, fcntl.fcntl(m_fd, fcntl.F_GETFL) | os.O_NONBLOCK)

            self.proc = subprocess.Popen(
                cmd, env=env, cwd=os.path.dirname(self.exe_file),
                stdin=s_fd, stdout=s_fd, stderr=s_fd, preexec_fn=os.setsid, pass_fds=(s_fd,) )

            os.close(s_fd); s_fd = None  # Close slave immediately
            self._monitor_final(m_fd)    # High-speed log capture
            self.done.emit(self.proc.wait() == 0) # wait() reaps the process so it doesn't stay as a 'zombie' in RAM

        except Exception as e:    self.log.emit(f"❌ Error: {str(e)}"); self.done.emit(False)
        finally:
            for fd in (f for f in (s_fd, m_fd) if f is not None):
                try: os.close(fd)
                except: pass

    def _monitor_final(self, m_fd):
        
        acc, last_emit = [], time.time()
        while self.proc.poll() is None or acc: # Loop while process runs OR data remains in buffer
            r, _, _ = select.select([m_fd], [], [], 0.02)    
            if r:
                try:
                    data = os.read(m_fd, 131072).decode(errors="ignore")
                    if data: acc.append(data)
                except (BlockingIOError, OSError):
                  if self.proc.poll() is not None: break

            now = time.time() # UI Batching: Emits every 200ms to keep gaming performance high
            if acc and (now - last_emit > 0.2):
                self.log.emit("".join(acc))
                acc, last_emit = [], now
            
            if self.proc.poll() is not None and not r: break # Instant exit if process is gone and no new data detected
        if acc: self.log.emit("".join(acc))

    def _build_command(self):
        env = { **os.environ, "WINEPREFIX": self.tprefix_path or "",
                "PYTHONUNBUFFERED": "1", "WINEDEBUG": "-all",

                    # Sync & Memory (The Speed Trio)
                "WINE_NO_ASLR": "1",# Speeds up large asset mapping
                "WINE_LARGE_ADDRESS_AWARE": "1", # Added for stability
                "WINE_NO_WRITE_WATCH":"1", # Unity/2D memory managing overhead-reduce

                    # Rendering & Shaders
                "vblank_mode": "0", # For Engine fastest assests-loading
                "DXVK_ASYNC": "1",
                "DXVK_STATE_CACHE":"1", 
                "LIBGL_ALWAYS_SOFTWARE":"0", # not forcing graphics software rendering
                "__GL_SHADER_DISK_CACHE": "1",
                "__GL_SHADER_DISK_CACHE_SKIP_CLEANUP": "1",

                    # System & Library Tweaks
                "STAGING_SHARED_MEMORY": "1",
                "LD_BIND_NOW": "1",
                "MALLOC_CHECK_": "0",
                "GALLIUM_HUD":"0", # For older hardware

                "WINE_FULLSCREEN_FSR":"0",
                "WINE_STDOUT_LINE_BUFFERED": "1",
                "WINEDLLOVERRIDES": "winhttp=n,b",
                "MONO_GC_PARAMS": "nursery-size=64m,soft-heap-limit=512m"
            }

        try:    # Sync Logic
            import resource
            if resource.getrlimit(resource.RLIMIT_NOFILE)[1] >= 65536:    env.update({ "WINEFSYNC": "1", "WINEESYNC": "1"})
        except: pass

        try:
            gpu = subprocess.check_output(["lspci"], text=True).lower()
            if "nvidia" in gpu :   env.update({"__GL_THREADED_OPTIMIZATIONS": "1", "NGX_ENABLE_DLSS_PRIMARY": "0"})
            if any(x in gpu for x in ["amd", "intel"]) :   env["mesa_glthread"] = "true"
        except: pass

        cmd = [ "taskset", "0xffffffff", self.wine ]
        if self.BepInEx_dll : cmd += [ "mono", self.BepInEx_dll ]
        cmd += [self.exe_file]
        return cmd, env
