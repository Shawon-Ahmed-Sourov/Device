# Launch: 10s ; DBar: 48s ; Display: 1m.16s ; GinaAppear: 3m.50s.

import os, pty, psutil, asyncio, subprocess
from PyQt5.QtCore import QThread, pyqtSignal

class RunAnalyze(QThread):
    
    log = pyqtSignal(str) ; done = pyqtSignal(bool)

    def __init__(self, exe_path, exe_file, tprefix_path=None, BepInEx_dll=None):
        super().__init__()
        self.wine = "wine"
        self.tprefix_path, self.BepInEx_dll, self.exe_file = tprefix_path, BepInEx_dll, exe_file

    def run(self):
        """Run the EXE in the background thread."""
        try:
            cmd, env = self._build_command()
            asyncio.run(self._launch_exe(cmd, env))  # Run asynchronously
        except Exception as e:    self.log.emit(f"❌ Run error: {e}"); self.done.emit(False)

    def _handle_error(self, message):   self.log.emit(f"❌ {message}");self.done.emit(False)

    def _build_command(self):
        env = {**os.environ, "WINEPREFIX": self.tprefix_path or "", "WINE_FULLSCREEN": "0", "WINEDEBUG": "+timestamp,+warn", "WINEESYNC": "1", "WINEFSYNC": "1", "WINEASYNC": "0"}
        cmd = [self.wine] + (["mono", self.BepInEx_dll] if self.BepInEx_dll else []) + [self.exe_file]
        return cmd, env

    async def _launch_exe(self, cmd, env):

        self.log.emit(f"Launching EXE: {' '.join(cmd)}")
        try:
            master_fd, slave_fd = pty.openpty()
            proc = await asyncio.create_subprocess_exec(*cmd, env=env, cwd=os.path.dirname(self.exe_file),
                        stdin=slave_fd, stdout=slave_fd, stderr=slave_fd, preexec_fn=os.setsid, bufsize=0, text=False)
            os.close(slave_fd)
            await self._monitor_pty(proc, master_fd)
            await self._check_process_resources(proc)
        except Exception as e: self._handle_error(f"Launch failed: {e}")

    async def _monitor_pty(self, proc, master_fd):

        loop = asyncio.get_event_loop()
        while proc.returncode is None:
            data = await loop.run_in_executor(None, lambda: os.read(master_fd, 1024).decode(errors="ignore"))
            if data:
                for line in data.splitlines(): 
                    self.log.emit(line)
            await asyncio.sleep(0.05)  # Slightly reduced delay for faster checks
        os.close(master_fd)
        self.done.emit(proc.returncode == 0)  # Emit success or failure based on exit code

    async def _check_process_resources(self, proc):

        if proc.returncode is not None: return # No need to check resources, as already exited
        try:
            p = psutil.Process(proc.pid)
            while proc.returncode is None:
                memory, cpu = p.memory_info().rss, p.cpu_percent(interval=1)
                if memory > 1e9 or cpu > 90:
                    self.log.emit(f"High resource usage : {memory / 1e6} MB, {cpu}% CPU"); break
                await asyncio.sleep(0.5)  # Reduced the frequency of resource checks to improve performance
        except psutil.NoSuchProcess: self.log.emit(f"As Process {proc.pid} may Exited, unfound during resource check.")


