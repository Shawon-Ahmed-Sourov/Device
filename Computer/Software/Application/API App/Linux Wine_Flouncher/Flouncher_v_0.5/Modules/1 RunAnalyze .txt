import os, pty, subprocess, select, fcntl, time, resource
from PyQt5.QtCore import QThread, pyqtSignal

class RunAnalyze(QThread):
    log, done = pyqtSignal(str), pyqtSignal(bool)

    def __init__(self, exe_path, exe_file, tprefix_path=None, BepInEx_dll=None):
        super().__init__()
        self.wine, self.proc, self.exe_file = "wine", None, exe_file
        self.tprefix_path, self.BepInEx_dll = tprefix_path, BepInEx_dll

    def run(self):
        self.log.emit("\n‚ö° Scalable Launch: Preparing hardware...")
        cmd, env = self._build_command()
        m_fd, s_fd = None, None
        try:
            m_fd, s_fd = pty.openpty()
            fcntl.fcntl(m_fd, fcntl.F_SETFL, fcntl.fcntl(m_fd, fcntl.F_GETFL) | os.O_NONBLOCK)            
                # Start process
            self.proc = subprocess.Popen( cmd, env=env, cwd=os.path.dirname(self.exe_file),
                stdin=s_fd, stdout=s_fd, stderr=s_fd, start_new_session=True, pass_fds=(s_fd,))
            
            os.close(s_fd); s_fd = None
            time.sleep(0.5) # Load info by polling
            self._monitor(m_fd) # Start monitoring immediately to prevent I/O backpressure
            self.done.emit(self.proc.wait() == 0)
        except Exception as e: self.log.emit(f"‚ùå Error: {e}"); self.done.emit(False)
        finally: [os.close(fd) for fd in (m_fd, s_fd) if fd is not None]

    def _monitor(self, m_fd): # 0 Lag Dynamic Buffer # smooth escalate+Walk From start
        try:
            mem = (os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_PHYS_PAGES')) / (1024**3)
            # Tier logic: Keep poll simple (0.1), change the buffer (buf)
            if mem > 12:   buf, poll = 1048576, 0.05 
            elif mem >= 3: buf, poll = 524288, 0.1    # 512KB Buffer / 10Hz
            else:          buf, poll = 65536, 0.15
        except:            buf, poll = 65536, 0.15 #<- changed this to basic one
            
        acc, last_emit = [], time.time()
        while self.proc.poll() is None or acc:
            # Simple select: no extra math, no extra time calls
            r, _, _ = select.select([m_fd], [], [], poll)
            if r:
                try:
                    # Reading a LARGER chunk (512KB) less often 
                    # is much easier on an i3 than reading small chunks fast.
                    data = os.read(m_fd, buf).decode(errors="replace")
                    if data: acc.append(data)
                except (OSError, BlockingIOError):
                    if self.proc.poll() is not None: break

            now = time.time()
            # Simple flush logic
            if acc and (now - last_emit > 0.5 or len(acc) > 100): self.log.emit("".join(acc)); acc, last_emit = [], now

            if self.proc.poll() is not None and not r: break
        if acc: self.log.emit("".join(acc))


        
    def _build_command(self):

        cores = os.cpu_count() or 4
        mask = hex((1 << cores) - 1)
        env = { **os.environ, "WINEPREFIX": self.tprefix_path or "",
                "PYTHONUNBUFFERED": "1", "WINEDEBUG": "-all",

                    # Sync & Memory (The Speed Trio)
                "WINE_NO_ASLR": "1",# Speeds up large asset mapping
                "WINE_LARGE_ADDRESS_AWARE": "1", # Added for stability
                "WINE_NO_WRITE_WATCH":"1", # Unity/2D memory managing overhead-reduce

                    # Rendering & Shaders
                "vblank_mode": "0", # For Engine fastest assests-loading
                "DXVK_ASYNC": "1",
                "DXVK_STATE_CACHE":"1",
                "DXVK_STATE_CACHE_WRITE_STRATEGY": "delayed", # Don't stutter the game to write cache files
                "DXVK_GPL_ASYNCHRONOUS": "1", # Modern zero-stutter shader tech
                "LIBGL_ALWAYS_SOFTWARE":"0", # Avoid Software Rendering
                "__GL_SHADER_DISK_CACHE": "1", # Shader disk cache
                "__GL_SHADER_DISK_CACHE_SKIP_CLEANUP": "1", # Skip shader cleanup
                "WINE_FULLSCREEN_FSR":"0", # Disable FSR (for smoother rendering)

                    # System & Library Tweaks
                "STAGING_SHARED_MEMORY": "1", # Reduce memory usage
                "LD_BIND_NOW": "1", # Memory binding optimizations
                "MALLOC_CHECK_": "0", # Disable malloc checks
                "WINE_STDOUT_LINE_BUFFERED": "1",
                "WINEDLLOVERRIDES": "winhttp=n,b",
                "MONO_GC_PARAMS": "nursery-size=64m,soft-heap-limit=512m" # Memory management for Mono
            }
        try: # Sync Logic
            if resource.getrlimit(resource.RLIMIT_NOFILE)[1] >= 524288: env.update({"WINEESYNC":"1","WINEFSYNC":"1"})
        except: pass

        try: # GPU Auto-Tuner
            gpu = subprocess.check_output(["lspci"], text=True).lower()
            if "nvidia" in gpu: env.update({"__GL_THREADED_OPTIMIZATIONS": "1"})
            if any(x in gpu for x in ["amd", "intel"]): env.update({"mesa_glthread": "true", "RADV_PERFTEST": "ngc"})
        except: pass

        cmd = ["taskset", mask, self.wine]
        if self.BepInEx_dll: cmd += ["mono", self.BepInEx_dll]
        return cmd + [self.exe_file], env

    def stop(self):
        """Forcefully kills process group and wipes the wineserver."""
        if not self.proc: return
        try:
            import signal
            os.killpg(os.getpgid(self.proc.pid), signal.SIGTERM)
            # -k sends a kill signal to all processes in the prefix immediately
            subprocess.call(["wineserver", "-k"], env={"WINEPREFIX": self.tprefix_path or ""})
            self.log.emit("\nüõë Emergency Stop: Process and Wine environment nuked.")
        except Exception as e: self.log.emit(f"‚ö†Ô∏è Shutdown error: {e}")
