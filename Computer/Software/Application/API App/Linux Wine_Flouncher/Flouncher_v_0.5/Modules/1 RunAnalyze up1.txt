# Launch: 9s;  DBar: 43s;  Display: 1min.8s;  Gina : 3m.35s

import os, time, selectors

class RunAnalyze(QThread):

    log  = pyqtSignal(str); done = pyqtSignal(bool)

    def __init__(self, exe_path, exe_file, tprefix_path=None, BepInEx_dll=None):
        super().__init__()
        self.wine = "wine"
        self.tprefix_path, self.BepInEx_dll, self.exe_file = tprefix_path, BepInEx_dll, exe_file


    def run(self):
        try:
            cmd, env = self._build_command()
            self._launch_exe(cmd, env)
        except Exception as e:    self.log.emit(f"❌ Run error: {e}"); self.done.emit(False)

    def _build_command(self):
        """Build the command for launching the exe with Wine."""
        env = {**os.environ, "WINEPREFIX": self.tprefix_path or "", "WINE_FULLSCREEN": "0", "WINEDEBUG": "+timestamp,+warn", "WINEFSYNC": "1", "WINEESYNC": "1"}
        cmd = [self.wine]
        if self.BepInEx_dll:    cmd.extend(["mono", self.BepInEx_dll])
        cmd.append(self.exe_file)
        return cmd, env

    def _launch_exe(self, cmd, env):

        self.log.emit(f"Launching EXE: {' '.join(cmd)}")
        try:
            master_fd, slave_fd = pty.openpty()

            proc = subprocess.Popen(cmd, env=env, cwd=os.path.dirname(self.exe_file),
                                 stdin=slave_fd, stdout=slave_fd, stderr=slave_fd, text=True, bufsize=1, close_fds=True)
            os.close(slave_fd)
            self._monitor_pty(proc, master_fd)
        except Exception as e: self.log.emit(f"❌ Launch failed: {e}") ; self.done.emit(False)

    def _monitor_pty(self, proc, master_fd):
        sel = selectors.DefaultSelector()
        sel.register(master_fd, selectors.EVENT_READ)

        buffer = ""
        last_emit = time.time()
        try:
            while True:
                events = sel.select(timeout=0.1)  # wait for data, timeout to check process
                for key, _ in events:
                    data = os.read(master_fd, 8192).decode(errors="ignore")
                    if data:    buffer += data

                # Batch emit every 0.1s
                if buffer and (time.time() - last_emit > 0.1):
                    self.log.emit(buffer)
                    buffer = ""
                    last_emit = time.time()

                # Exit if process ended
                if proc.poll() is not None:
                    if buffer:    self.log.emit(buffer)  # emit remaining
                    self.log.emit(f"Wine process {proc.pid} exited with code {proc.returncode}")
                    break
        finally:
            sel.unregister(master_fd)
            os.close(master_fd)
            if proc.poll() is None:proc.kill()
            self.done.emit(proc.returncode == 0)
