import os, pty, threading, subprocess
from PyQt5.QtCore import QThread, pyqtSignal
from queue import Queue

class RunAnalyze(QThread):

    log = pyqtSignal(str) ; done = pyqtSignal(bool)

    def __init__(self, exe_path, exe_file, tprefix_path=None, BepInEx_dll=None):
        super().__init__()
        self.wine = "wine"
        self.tprefix_path = tprefix_path
        self.BepInExEx_dll = BepInEx_dll
        self.exe_file = exe_file

    def run(self):
        """Run the EXE in a background thread with PTY and decoupled logging."""
        try:
            cmd, env = self._build_command()
            self._launch_exe(cmd, env)
        except Exception as e: self.log.emit(f"❌ Run error: {e}") ; self.done.emit(False)

    def _build_command(self):
        env = {
            **os.environ,
            "WINEPREFIX": self.tprefix_path or "",
            "WINE_FULLSCREEN": "0",
            "WINEDEBUG": "+timestamp,+warn",
            "WINEESYNC": "1",
            "WINEFSYNC": "1",
            "WINEASYNC": "0"
        }
        cmd = [self.wine]
        if self.BepInExEx_dll: cmd += ["mono", self.BepInExEx_dll]
        cmd += [self.exe_file]
        return cmd, env

    def _launch_exe(self, cmd, env):
        self.log.emit(f"Launching EXE: {' '.join(cmd)}")
        try:
            master_fd, slave_fd = pty.openpty()

            proc = subprocess.Popen(
                cmd,env=env,cwd=os.path.dirname(self.exe_file),
                stdin=slave_fd,stdout=slave_fd,stderr=slave_fd,
                close_fds=True
            )
            os.close(slave_fd)

            # Use a queue to decouple PTY reading from logging
            log_queue = Queue(maxsize=10000)

            # Start PTY reader thread (fast path)
            reader_thread = threading.Thread(target=self._pty_reader, args=(master_fd, log_queue), daemon=True)
            reader_thread.start()

            # Start logger thread (slow path)
            logger_thread = threading.Thread(target=self._logger_worker, args=(log_queue,), daemon=True)
            logger_thread.start()

            # Wait for process to finish
            proc.wait()

            # Signal threads to finish
            log_queue.put(None)
            reader_thread.join()
            logger_thread.join()

            self.done.emit(proc.returncode == 0)

        except Exception as e: self.log.emit(f"❌ Launch failed: {e}") ; self.done.emit(False)

    def _pty_reader(self, fd, queue):
        """Fast PTY reader: read raw bytes and push to queue."""
        try:
            while True:
                try:
                    data = os.read(fd, 8192)
                    if not data: break
                    queue.put(data)
                except OSError: break
        finally: os.close(fd)

    def _logger_worker(self, queue):
        """Slow path: decode, emit log signals, optionally save to file."""
        while True:
            data = queue.get()
            if data is None: break
            text = data.decode(errors="ignore")
            for line in text.splitlines(): self.log.emit(line)
